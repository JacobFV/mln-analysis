\hypertarget{code-organization}{%
\section{Code Organization}\label{code-organization}}

Code is organized under the following major files and directories:

\begin{verbatim}
├── docs: documentation for us, future developers, and the community
├── public: static web resources. next.js requires this to be in the root
├── research: some papers that might be relevant for the project
├── src: source code goes here
│   ├── apps: backend applications that the server interfaces with
│   ├── common: code shared by both the frontend and backend
│   |   ├── misc: miscellaneous code that doesn't fit anywhere else
│   |   ├── types: types that are used by multiple files including the database
│   |   ├── utils: utility functions that are / might be used by multiple files
│   |   ├── constants: important shared constants
│   |   └── ...
│   ├── components: ReactJS components which are included in pages
│   ├── pages: next.js routes '/url/path' to the corresponding default export at '/src/pages/<url/path>'
│   |   ├── api: pages and api endpoints
│   |   |   ├── graphql.ts: the handler for all graphql functions
│   |   |   ├── auth: next.js authentication handling
│   |   |   └── ... other rest api endpoints
│   |   └── ... pages
│   ├── prisma: database schema and sqlite saves
│   ├── server: server-side-only code used in API endpoints
│   └── styles: stylesheets
├── storage: entity-segmented storage
├── test: ts mocha tests
├── README: overview page for MLN-Dashboard
├── LICENSE: MIT License
├── .env.local: environment file with variables included (not in git)
├── .env.local.example: empty environment file
├── .next: next.js-compiled app
└── ... developer files (vscode, git, npm)
\end{verbatim}

\hypertarget{code-style}{%
\subsection{Code Style}\label{code-style}}

Code (mostly) adheres to
\href{https://google.github.io/styleguide/jsguide.html}{Google's
JavaScript Style Guide}:

\begin{itemize}
\tightlist
\item
  camelCase is used for variable names and modularized css classes
\item
  \texttt{const} instead of \texttt{var} or \texttt{let} is employed
  wherever possible
\item
  jsdoc comments are / should be included for each function/class/etc.
\end{itemize}

While no hard formatting rules are enforced, eg, indentation level, tab
vs.~space, max length, etc., the code is formatted in a way that is easy
to read and modify.

\hypertarget{documentation}{%
\subsection{Documentation}\label{documentation}}

Once the backend is stable, \href{https://codecrumbs.io/}{codecrumbs}
and/or
\href{https://bogdan-lyashenko.github.io/js-code-to-svg-flowchart/docs/live-editor}{js-code-to-svg-flowchart}
will be used to make visual documentation of the server logic.

Unless otherwise specified, filenames is the MLN-Dashboard documentation
are relative to the repository's root or the \texttt{/src} directory;
\texttt{/} does NOT indicate that a path is relative to the operating
system's root.

Effort is made to keep the overall repo should be versionless in-between
major version numbers. Following GitHUb's recommendations, minor changes
should retain backwards compatibility. API endpoints are a necessary
exception; all past and present API versions are organized by major
releases. This further facilitates code reuse across versions.
Currently, the API is on \texttt{v1}. Once a stable beta is reached, the
contents of \texttt{/src/pages/api} will be moved to
\texttt{/src/pages/api/v1}.

\hypertarget{tests}{%
\subsection{Tests}\label{tests}}

Tests are placed in the \texttt{/test} subdirectory and performed using
\texttt{mocha}. This section will be expanded once tests are setup.

\hypertarget{authentication-verification-and-security}{%
\section{Authentication, Verification, and
Security}\label{authentication-verification-and-security}}

This app uses \textbf{\href{https://jwt.io/}{json web tokens}} (JWT) to
authenticate users. JWT tokens are signed with the environment variable
\texttt{JWT\_SECRET} in \texttt{.env.local}. If you are deploying this
in a production environment, you will want to automate
nightly/weekly/monthly key rotations.

The \textbf{\texttt{nextauth.js}} library makes it easy to support many
different authentication providers. To test them, you will need to get
your own access tokens and secrets. See the links in the
\texttt{.env.local.example} file on how to obtain these.

For \textbf{password authentication}, the passwords are salted and
stretched using the \texttt{bcrypt} library. Only the resulting hash is
stored in the database. Users might not have a password hash if they use
other authentication methods.

\textbf{Email verification}. All emails must be verified before they can
be used. A verification code is sent whenever:

\begin{itemize}
\tightlist
\item
  a new user is created,
\item
  a new email is added to an existing account, or
\item
  a user clicks ``resend verification code'' on the verify page.
\end{itemize}

Unverified users are automatically redirected to the check email page.

Since email addresses can change, \textbf{users are \emph{not} uniquely
identified by their email address}. The \texttt{user} object is uniquely
identified by its \texttt{id}. This provides a stable point of reference
to use when setting permissions on users who may change their emails /
merge accounts / disable password sign in / etc. Also, since JWT's
identify users by their email, a new account is created each time the
user signs in using an auth provider that is under a different email
address. This creates a problem where a user could have multiple
accounts. To prevent this issue, users can select to merge into an
existing account when authenticating with a new email. This feature is
not yet implemented.

\textbf{Abuse protection}. REST API requests and GraphQL queries are
rate limited to prevent abuse. The rate limit is implemented with a
leaky bucket algorithm on a per-IP address basis for unauthenticated
users and per-user basis for authenticated users. Additionally, app
usage is rate limited, but this better explained in the
\href{/docs/apps.md}{apps documentation}. This feature is not yet
implemented.

\textbf{Containerization}. Apps are launched in containers under an
OS-user which only has read and write access to the corresponding subset
of the \texttt{/storage} directory that the user who launched the
application has permissions to read and write respectively. After
execution is complete, a diff is performed across all files and
directories that the user has permissions to write to, and the changes
are pulled into the main content directory. The entire server is also
containerized and only has permissions to read and write to the
repository root directory. The storage directory is backed up and the
entire app container is deleted, re-downloaded, restarted every night.
This feature is not yet implemented.

\hypertarget{authorization}{%
\section{Authorization}\label{authorization}}

Authorization is the process of establishing what privileges and
permissions a user has. Currently, all functionality that requires
authorization is implemented on the GraphQL resolver functions. See the
\href{/docs/backend.md}{schema description} for details. We currently
use authorization for the following purposes:

\textbf{Restricting access to privileged information on the graphql
api}: For example, a user cannot see another user's alternative emails,
their own login attempts, or anybody's password hash. Users must belong
to a given group to see that group's information.

\textbf{Restricting access to files}: See
\href{/docs/file_permissions.md}{file\_permissions.md} for more
information.

Authentication is not necessary to have authorization in every case.
Clients are authenticated as \texttt{Anonymous} users by default.

\hypertarget{users-and-groups}{%
\section{Users and Groups}\label{users-and-groups}}

Resources are owned by either a \textbf{user} or a \textbf{group}. Users
and groups are both a type of \textbf{entity}. Groups contain users and
groups and are useful for managing organizations or establishing
hierarchial permissions for a collection of entities. Every entity has:

\begin{itemize}
\tightlist
\item
  metadata, including a unique ID, name, dateCreated, etc.
\item
  a top-level storage directory. This directory is located at
  \texttt{/storage/\textless{}entityID\textgreater{}}.
\end{itemize}

The \texttt{\textless{}entityID\textgreater{}} field is
\texttt{u\{\textless{}user.ID\textgreater{}\}} for users and
\texttt{g\{\textless{}group.ID\textgreater{}\}} for groups. This allows
us to take advantage of prisma's \texttt{unique} ID auto-generation
while avoiding namespace collisions between users and groups.

Please note: ``users'' and ``groups'' in this context are not the same
as linux users and groups. The server can run under any linux user. It
implements users and groups on its own layer of abstraction, and it only
modifies files under its own repository root directory. See
\href{/docs/authentication_verification_and_security.md}{security
\textgreater{} containerization} for information about the impact this
server makes on its host system.

\hypertarget{creating-users-and-groups}{%
\subsection{Creating Users and Groups}\label{creating-users-and-groups}}

Users are created when either:

\begin{itemize}
\tightlist
\item
  a person authenticates with a new third party identity and the email
  attached to the OAuth identity is not already in the database or
\item
  a \texttt{createAccount} mutation is sent to create a
  credential-authenticated account.
\end{itemize}

See the \texttt{/src/pages/api/auth/{[}...nextauth{]}.js}
\texttt{async\ signIn} function and \texttt{createAccount} graphQL
mutation for details on how this is handled.

Groups are created by a user with the \texttt{createGroup} mutation. See
the \texttt{createGroup} mutation for details.

\hypertarget{special-users}{%
\subsection{Special Users}\label{special-users}}

There are two special users:

\begin{itemize}
\tightlist
\item
  \texttt{Anonymous} user: the user who is not logged in. This
  psuedo-user exists for the purpose of being able to assign public read
  and write permissions to files.
\item
  \texttt{System} user: the system user is used in cases where nobody
  should have control of a resource. For example, each user's top-level
  directory is owned by the \texttt{System} user to prevent them from
  doing something stupid like giving away ownership rights on their own
  top-level directory. The \texttt{System} user also owns the root
  storage directory. See \href{/docs/authorization.md}{authorization}
  for more information.
\end{itemize}

\hypertarget{apps}{%
\section{Apps}\label{apps}}

\textbf{App} are the building blocks of the server's application layer.
Right now, all apps are treated as black box programs. (Actually, right
now, I don't have any apps.) However, explicit interfaces are specified
for each application, leaving the room open to make a block-programming
editor in the future or even directly invoke transparent javascript or
python functions.

Apps are listed in the \texttt{/src/apps} directory. Each app has a
\texttt{manifest.ts} file in its root with a default export function
that specifies the app's name, description, and other metadata like so:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{default} \FunctionTok{export}\NormalTok{ ()}\OperatorTok{:}\NormalTok{ AppManifest }\KeywordTok{=>} \OperatorTok{\{}
  \ControlFlowTok{return} \KeywordTok{new} \OperatorTok{\{}
\NormalTok{    name}\OperatorTok{:} \StringTok{'My App'}\OperatorTok{,}
\NormalTok{    description}\OperatorTok{:} \StringTok{'A description of my app'}\OperatorTok{,}
    \OperatorTok{...}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The returned object should conform to the \texttt{AppManifest} type.
This manifest object allows the server to automatically index, display,
and build user interfaces for each app. It contains \texttt{inputs} and
\texttt{outputs} which determine the editable and viewable UI components
presented to the user before and after application execution
respectively. Under the hood, these type specifications are represented
using instances of \texttt{AnyType} and subclasses which allows
overriding where necessary but simplicity when convenient. See
\texttt{/src/common/apps/{[}...appTypes{]}.ts} for more details.

It's not recommended to develop apps directly inside this repository.
Instead, apps should be developed in their own repository and added as a
\href{https://git-scm.com/book/en/v2/Git-Tools-Submodules}{git
submodule} in the /apps directory. Once your app is ready, run
\texttt{git\ add-submodule\ https://github.com/user/repo.git\ apps/my-submodule}
to add it to the server. If you don't want the AppManifest to be
included in your main remote, create a new branch with the AppManifest
included. Remember, contents inside git submodules don't get versioned
along with the main repository. The main repo merely points to the most
recent local commit of that submodule.

In the future block-based programming editor, this input and output type
metadata will be used to annotate input and output ports of nodes (which
represent app executions in a workflow) with a specific color or shape.
Users will be able to drag and drop these nodes into the workflow editor
to create a multi-app workflow. See
\url{https://github.com/JacobFV/EasyMLN} for a longer description of
this idea.

\hypertarget{client}{%
\section{Client}\label{client}}

The client recieves pages served from the \texttt{/pages} directory
which are written in JSX and TSX (mostly typescript).

The following libraries / modules were initially considered when
developing MLN-Dashboard:

\begin{itemize}
\tightlist
\item
  preact: possible lightweight react alternative
\item
  material-ui and mui: developer-friendly, accelerate development time,
  meet user expectations on both desktop and mobile, different screen
  sizes, and with accessibility requirements.
\item
  apollo ecosystem: flexible and complex queries with client-side
  caching.
\item
  Modularized SASS: for flexible styling with jsx/tsx.
\end{itemize}

Preact was rejected for its limited component library. While the
material-ui framework was initially selected for aesthetic appeal, its
heavy weight made development and page loading times excessively long.
After exploring the web development ecosystem on GitHub, we discovered
\texttt{mantine}, a library that builds on top of react and provides
specific components that we will needed including:

\begin{itemize}
\tightlist
\item
  \texttt{@mantine/dropzone}: uploading files
\item
  \texttt{@mantine/modals}: simple modal dialogs
\item
  \texttt{@mantine/rte}: rich text editor for making research reports
  with support for formatting, tables, lists, image uploads, video
  embedding, and mentions of other users
\item
  \texttt{@mantine/hooks}: qt form builder for lgoin, registration, and
  other forms
\item
  \texttt{Spoiler}: provide short summaries of an author's research
\item
  \texttt{AppShell}: quick app template UI component
\item
  \texttt{Grid}: flexible layout
\item
  \texttt{Autocomplete}: options for application input
\item
  \texttt{SegmentedControl}: options for application output
\item
  \texttt{Breadcrumbs}: file navigation
\item
  \texttt{Stepper}: progress bar for application execution and creating
  new accounts
\end{itemize}

At its current state, we are employing the following client-side stack:

\begin{itemize}
\tightlist
\item
  JSX/TSX/React: used for defining code alongside view components
\item
  mantine: supplies high-level user interface components
\item
  apollo/client: used for communicating with the server
\end{itemize}

\hypertarget{backend}{%
\section{Backend}\label{backend}}

When you're talking about a reasonably complex server like this one, the
term `backend' is kind of vague. I'm going to describe it in three
classes:

\begin{itemize}
\tightlist
\item
  \textbf{API endpoints}. These are located in the \texttt{/pages/api}
  folder. Like any other Next.js page, whenever the user navigates to
  \texttt{http://localhost:\textless{}app\_port\textgreater{}/api/...},
  the corresponding default export function in \texttt{/pages/api/...}
  is called. Much of the API is interfaced through a GraphQL schema at
  \texttt{/api/graphql}. In the future, API endpoints will be versioned
  by \texttt{/api/v1/...}, so we can update the API without breaking the
  frontend.
\item
  \textbf{Server-only code}. Many API endpoints use the same code or
  there may be cases where it may be cleaner to consolidate the code
  that a single endpoint uses in separate files for readability,
  extendability, or versioning reasons. This server-only code is located
  in the \texttt{/server} folder. These functions do not* operate on
  HTTP requests or responses and are not directly exposed to the client.
\item
  \textbf{Applications}. Now we're in the deep-backend. These are the
  essential programs that this web app provides an interface to. For
  MLN-Dashboard, examples of apps could be graph generation,
  visualization, and data retrieval tools. This code is located in the
  \texttt{/src/apps} folder. See the \href{/docs/apps.md}{Apps}
  documentation page for details.
\end{itemize}

\hypertarget{common-types-database-and-graphql}{%
\subsection{Common Types, Database, and
GraphQL}\label{common-types-database-and-graphql}}

This server is a hybrid RESTful / GraphQL server. The RESTful API is
exposed to the client via the \texttt{/src/api} endpoint. The GraphQL
API is exposed to the client at a single endpoint:
\texttt{/src/api/graphql}. Please skim the
\href{/https://graphql.org/learn/}{GraphQL Documentation} for an
introduction to GraphQL if you are not familiar with it.

I think we should make as much data as possibly directly accessible to
the frontend via GraphQL. This should help keep things simple, flexible,
understandable, and maintainable while also allowing for complex server
logic to be added in the future. To minimize complexity and maximize
efficiency, the graphql schema is aligned as closely as is reasonably
possible with the database. Directives defined on the schema
(@authenticated, @owner, @private, etc.) establish how the client can
interact with schema fields. Directives include:

\begin{itemize}
\tightlist
\item
  \texttt{@readIfAuthenticated}: This directive requires that the client
  be authenticated. If the client is not authenticated, the field is not
  returned (without sending an error message).
\item
  \texttt{@readIfOwner}: This directive requires that the client be
  authenticated and that the client be the owner of the object. If the
  client is not authenticated or is not the owner of the object, the
  field is not returned. The \texttt{owner} is defined differently
  depending on the resource. For example, the owner of a file is defined
  by the \texttt{file.owner.guid} field; the owner of a user is defined
  by the \texttt{user.guid} field; the owner of an organization is
  defined by the \texttt{organization.owner.guid} field.
\item
  \texttt{@private}: This directive indicates the field is private.
  Private fields are never returned to the client regardless of
  authentication. In fact, they might be implemented by completely
  removing the field from the graphql schema.
\item
  no visibility directive: Fields are public by default. Public fields
  are always returned -- unless, of course, an error occurs.
\item
  \texttt{@immutable}: This directive indicates the field or object will
  not change and can be safely cached.
\item
  \texttt{@deprecated}: This directive indicates the field is
  deprecated. Deprecated fields or mutations are returned to the client
  with a warning message. There should not be a reason to use this
  directive at the early development stage we are in.
\item
  \texttt{@unique}: This directive indicates that all values for the
  field should be unique. An error is thrown if the client attempts to
  set a value that results in a value-space collision.
\item
  \texttt{@paginated}: This directive indicates that the field is
  paginated. This means that the field is an array of objects and the
  client can request a specific page of the array. The client can
  request a page of the array by specifying the \texttt{page} and
  \texttt{pageSize} query parameters. The \texttt{page} parameter is
  1-indexed. The \texttt{pageSize} parameter is the number of objects to
  return in the page. The default page size is 10. If no parameters are
  specified, the entire array is returned.
\item
  \texttt{@lazy}: This directive indicates that the object is undefined
  until it is requested the first time -- hence, lazy loading. If the
  value changes, the object will be deleted and once again be undefined.
\end{itemize}

It's hard to explain what the GraphQL schema looks like without also
discussing common types and the database:

\begin{itemize}
\tightlist
\item
  Common types (like \texttt{User}, \texttt{FilePermissions}, etc.) are
  defined in the \texttt{/src/common/types} folder. This allows types to
  be shared across the server and the frontend.
\item
  The `database' is a singleton object that stores all persistent data
  (users, file permissions, etc.). This object is saved and loaded using
  json serialization/deserialization and can be retrieved on the server
  side using \texttt{/server/db.js:singleton()}.
\item
  The GraphQL schema and associated resolver functions are defined in
  the \texttt{/pages/api/v1/graphql} folder. The graphql endpoint
  manages interfacing with the database, provides server-side API
  functionality via graphql mutations, and can be extended for
  collaborative editing using graphql subscriptions.
\end{itemize}

There are many similarities between the database and graphql schema --
the main difference being that the database is actually a
javascript/typescript object, it doesn't include the \texttt{query},
\texttt{mutate} or \texttt{subscription} objects, and it replaces
objects with their guid when serializing. On the other hand, the graphql
schema doesn't include the \texttt{root} object and links directly to
the objects pointed to by a guid. Please see
\texttt{/src/common/types/*}, \texttt{/src/server/db.ts},
\texttt{/src/pages/api/v1/graphql.ts} for exact definitions.

Note also: in most cases where a user want to do something that requires
authorization, we don't trust the graphql api for the \texttt{email} or
\texttt{guid}. That's because anybody can make a request on behalf of a
user with a given email. Instead, the email, guid, and associated user
object is retrieved on the server-side using the client's JWT. That's
why you'll see mutations like \texttt{deleteAccount()} with no
\texttt{email} or \texttt{guid} arguments.

Here's the database and types:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{interface} \BuiltInTok{Node} \OperatorTok{\{}
\NormalTok{  guid}\OperatorTok{:}\NormalTok{ ID}\OperatorTok{!}\NormalTok{ @unique @immutable}
\OperatorTok{\}}
\NormalTok{scalar DateTime }\CommentTok{// javascript Date object as string `YYYY-mm-DD HH:MM:SS.SSS`}
\KeywordTok{interface} \BuiltInTok{Node} \OperatorTok{\{}
\NormalTok{  guid}\OperatorTok{:}\NormalTok{ ID}\OperatorTok{!}\NormalTok{ @unique @immutable}
\OperatorTok{\}}
\KeywordTok{interface}\NormalTok{ Entity }\KeywordTok{implements} \BuiltInTok{Node} \OperatorTok{\{}
\NormalTok{  guid}\OperatorTok{:}\NormalTok{ ID}\OperatorTok{!}\NormalTok{ @unique @immutable}
\NormalTok{  createdAt}\OperatorTok{:}\NormalTok{ DateTime}\OperatorTok{!}
\NormalTok{  updatedAt}\OperatorTok{:}\NormalTok{ DateTime}\OperatorTok{!}
\NormalTok{  name}\OperatorTok{:} \BuiltInTok{String}\OperatorTok{!}
\OperatorTok{\}}
\KeywordTok{type}\NormalTok{ Group }\KeywordTok{implements}\NormalTok{ Entity }\OperatorTok{\{}
  \CommentTok{// groups also have their own storage folder}
\NormalTok{  guid}\OperatorTok{:}\NormalTok{ ID}\OperatorTok{!}
\NormalTok{  createdAt}\OperatorTok{:}\NormalTok{ DateTime}\OperatorTok{!}
\NormalTok{  updatedAt}\OperatorTok{:}\NormalTok{ DateTime}\OperatorTok{!}
\NormalTok{  name}\OperatorTok{:} \BuiltInTok{String}\OperatorTok{!}
\NormalTok{  owner}\OperatorTok{:}\NormalTok{ User}\OperatorTok{!}
\NormalTok{  dateCreated}\OperatorTok{:} \BuiltInTok{String}\OperatorTok{!}
\NormalTok{  dateModified}\OperatorTok{:} \BuiltInTok{String}
\NormalTok{  members}\OperatorTok{:} \OperatorTok{[}\NormalTok{User}\OperatorTok{!]}
\OperatorTok{\}}
\KeywordTok{type}\NormalTok{ User }\KeywordTok{implements}\NormalTok{ Entity }\OperatorTok{\{}
\NormalTok{  guid}\OperatorTok{:}\NormalTok{ ID}\OperatorTok{!}
\NormalTok{  email}\OperatorTok{:} \BuiltInTok{String}\OperatorTok{!}
\NormalTok{  otherEmails}\OperatorTok{:} \OperatorTok{[}\BuiltInTok{String}\OperatorTok{!]}
\NormalTok{  name}\OperatorTok{:} \BuiltInTok{String}\OperatorTok{!}
\NormalTok{  picture}\OperatorTok{:} \BuiltInTok{String}\OperatorTok{!} \CommentTok{// url to profile picture. might be served from this server or elsewhere}
\NormalTok{  dateOfBirth}\OperatorTok{:}\NormalTok{ DateTime}\OperatorTok{!} \CommentTok{// policy purposes only}
\NormalTok{  dateCreated}\OperatorTok{:} \BuiltInTok{String}\OperatorTok{!}
\NormalTok{  dateModified}\OperatorTok{:} \BuiltInTok{String}
\NormalTok{  loginAttempts}\OperatorTok{:} \OperatorTok{[\{}
\NormalTok{    token}\OperatorTok{:} \DataTypeTok{string}
\NormalTok{    date}\OperatorTok{:} \BuiltInTok{Date}
\NormalTok{    sucess}\OperatorTok{:} \DataTypeTok{boolean}
  \OperatorTok{\}]}
\NormalTok{  passwordHash}\OperatorTok{:} \BuiltInTok{String}
\NormalTok{  resetPasswordToken}\OperatorTok{:} \BuiltInTok{String} \CommentTok{// short alphanumeric code}
\NormalTok{  groups}\OperatorTok{:} \OperatorTok{[}\NormalTok{Group}\OperatorTok{!]} \CommentTok{// list of Group guids}
\NormalTok{  verification_needed}\OperatorTok{:} \BuiltInTok{Boolean} \CommentTok{// if true, the user needs to verify their email address to log in with password authentication}
\NormalTok{  verification_code}\OperatorTok{:} \BuiltInTok{String} \CommentTok{// short alphanumeric code}
\NormalTok{  verification_date}\OperatorTok{:} \BuiltInTok{String} \CommentTok{// date the verification code was sent}
\OperatorTok{\}}
\KeywordTok{enum}\NormalTok{ PermissionLevel }\OperatorTok{\{}
\NormalTok{  READER}
\NormalTok{  WRITER}
\NormalTok{  ADMIN}
\NormalTok{  OWNER}
\OperatorTok{\}}
\KeywordTok{type}\NormalTok{ FilePermission }\OperatorTok{\{}
\NormalTok{  user}\OperatorTok{:}\NormalTok{ User}\OperatorTok{!}
\NormalTok{  permissionLevel}\OperatorTok{:}\NormalTok{ PermissionLevel}\OperatorTok{!}
\OperatorTok{\}}
\KeywordTok{type} \BuiltInTok{File} \OperatorTok{\{}
\NormalTok{  fullPath}\OperatorTok{:} \BuiltInTok{String}\OperatorTok{!}
\NormalTok{  owner}\OperatorTok{:}\NormalTok{ User}\OperatorTok{!} \CommentTok{// is an  admin, writer, and reader}
\NormalTok{  permissions}\OperatorTok{:} \OperatorTok{[}\NormalTok{FilePermission}\OperatorTok{!]!}
\NormalTok{  dateCreated}\OperatorTok{:} \BuiltInTok{String}\OperatorTok{!}
\NormalTok{  dateModified}\OperatorTok{:} \BuiltInTok{String}\OperatorTok{!}
\NormalTok{  size}\OperatorTok{:}\NormalTok{ Int }\CommentTok{// bytes}
\OperatorTok{\}}
\KeywordTok{type}\NormalTok{ App }\OperatorTok{\{}
\NormalTok{  name}\OperatorTok{:} \BuiltInTok{String}\OperatorTok{,}
\NormalTok{  description}\OperatorTok{:} \BuiltInTok{String}\OperatorTok{,}
\NormalTok{  version}\OperatorTok{:} \BuiltInTok{String}\OperatorTok{,}
\NormalTok{  invocation_template}\OperatorTok{:} \BuiltInTok{String}\OperatorTok{,} \CommentTok{// eg. `node ./index.js $arg1 --arg2 $arg3`}
\NormalTok{  inputs}\OperatorTok{:} \OperatorTok{\{}
    \OperatorTok{[}\NormalTok{name}\OperatorTok{:} \DataTypeTok{string}\OperatorTok{]:} \OperatorTok{\{}
\NormalTok{      type}\OperatorTok{:}\NormalTok{ Type}\OperatorTok{,}
\NormalTok{      description}\OperatorTok{:} \DataTypeTok{string}\OperatorTok{,}
\NormalTok{      required}\OperatorTok{:} \DataTypeTok{boolean}\OperatorTok{,}
      \ControlFlowTok{default}\OperatorTok{:} \DataTypeTok{any}\OperatorTok{,}
    \OperatorTok{\},}
  \OperatorTok{\},}
\NormalTok{  outputs}\OperatorTok{:} \OperatorTok{\{}
    \OperatorTok{[}\NormalTok{name}\OperatorTok{:} \DataTypeTok{string}\OperatorTok{]:} \OperatorTok{\{}
\NormalTok{      type}\OperatorTok{:}\NormalTok{ Type}\OperatorTok{,}
\NormalTok{      description}\OperatorTok{:} \DataTypeTok{string}\OperatorTok{,}
    \OperatorTok{\},}
  \OperatorTok{\},}
\OperatorTok{\}}
\NormalTok{db }\OperatorTok{\{}
\NormalTok{  users}\OperatorTok{:} \OperatorTok{[}\NormalTok{User}\OperatorTok{!]!}
\NormalTok{  organizations}\OperatorTok{:} \OperatorTok{[}\NormalTok{Organization}\OperatorTok{!]!}
\NormalTok{  filePermissions}\OperatorTok{:} \OperatorTok{[}\NormalTok{String}\OperatorTok{:}\NormalTok{ FilePermission}\OperatorTok{!]!} \CommentTok{// key is filepath}
  \CommentTok{// there is no persistent data for files; we use the OS filesystem instead!}
\NormalTok{  apps}\OperatorTok{:} \OperatorTok{[}\NormalTok{App}\OperatorTok{!]!}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

And here's the graphql schema:

\begin{verbatim}
\end{verbatim}

\begin{verbatim}
scalar DateTime // javascript Date object as string `YYYY-mm-DD HH:MM:SS.SSS`
interface Node {
  guid: ID! @unique @immutable
}
type LoginAttempt {
  token: String!
  date: DateTime!
  sucess: Boolean!
}
interface Entity implements Node {
  guid: ID! @unique @immutable
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
}
type Group implements Entity {
  // groups also have their own storage folder
  guid: ID! @unique @immutable
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  owner: User! @owner
  dateCreated: String! @private
  dateModified: String @private
  members: [User!]
}
type User implements Entity {
  guid: ID!
  email: String! @unique
  otherEmails: [String!]
  name: String!
  picture: String! // url to profile picture. might be served from this server or elsewhere
  dateOfBirth: DateTime! @private // policy purposes only
  dateCreated: String! @private
  dateModified: String @private
  loginAttempts: [LoginAttempt!]! @private
  passwordHash: String @private
  resetPasswordToken: String @private // short alphanumeric code
  groups: [Group!] // list of Group guids
  verification_needed: Boolean @private // if true, the user needs to verify their email address to log in with password authentication
  verification_code: String @private // short alphanumeric code
  verification_date: String @private // date the verification code was sent
}
enum PermissionLevel {
  READER
  WRITER
  ADMIN
  OWNER
}
type FilePermission {
  user: User!
  permissionLevel: PermissionLevel!
}
type File {
  fullPath: String!
  owner: User! // is an  admin, writer, and reader
  permissions: [FilePermission!]!
  dateCreated: String!
  dateModified: String!
  size: Int // bytes
}
type App {
  name: String,
  description: String,
  version: String,
  invocation_template: String, // eg. `node ./index.js $arg1 --arg2 $arg3`
  inputs: {
    [name: string]: {
      type: Type,
      description: string,
      required: boolean,
      default: any,
    },
  },
  outputs: {
    [name: string]: {
      type: Type,
      description: string,
    },
  },
}
db {
  users: [User!]!
  organizations: [Organization!]!
  filePermissions: [String: FilePermission!]! // key is filepath
  // there is no persistent data for files; we use the OS filesystem instead!
  apps: [App!]!
}
query {
  users: [User!]!
  // file permissions are accessible inside `files`
  files(path: String!, depth: Int = 0): [File!]|string // returns an error message if the path is invalid or user does not have permission
  apps: [App!]!
}
mutate {
  createCredentialAuthenticatedUser(email: String, name: String, password: String) {
     result: String
  }
  // send email with verification code to user
  resendVerificationEmail(email: String) {
     result: String
  }
  // verify user's email address using verification code
  verifyEmail(verificationCode: String) {
     result: String
  }
  deleteUser() {
     result: String
  }
  changeUsername(newUsername: String) {
     result: String
  }
  mergeIntoOtherAccount(otherAccountEmail: String) {
     result: String
  }
  changePassword(oldPassword: String, newPassword: String) {
     result: String
  }
  // send email with reset password code to user
  forgotPassword(email: String) {
     result: String!
  }
  // reset user's password using reset password code
  resetPassword(email: String, resetPasswordToken: String, newPassword: String) {
     result: String
  }
  createGroup(name: String!) {
     result: String
  }
  deleteGroup(guid: ID!) {
     result: String
  }
  addUserToGroup(userGuid: ID!, groupGuid: ID!) {
     result: String
  }
  removeUserFromGroup(userGuid: ID!, groupGuid: ID!) {
     result: String
  }
  setPermisssions(path: String!, permissions: FilePermissionInput!) {
     result: String
  } // TODO: change permission to permissionLevels
  // TODO: completely separate the database from graphql schema
}
subscription {
  ...
}
\end{verbatim}

Also, the GraphQL website
\href{https://graphql.org/learn/best-practices/}{made some
recommendations} on development and deployment considerations:

\begin{quote}
It's encouraged that any production GraphQL services enable GZIP and
encourage their clients to send the header:

\begin{quote}
Accept-Encoding: gzip
\end{quote}
\end{quote}

\hypertarget{password-reset-sequence}{%
\subsubsection{Password reset sequence}\label{password-reset-sequence}}

NOTE: The user can exit this sequence anytime before they reach step 7
without resetting their password.

\begin{verbatim}
1. User clicks the "forgot my password" link from the sign in page

2. Link navigates user to the `/account/forgot_password` page

3. User enters their email address and submits

4. The forgot password form invokes the `/api/v1/account/ forgot_password` endpoint with the user's email address

4.1. If the email address is not found, the server returns `200 OK` // the server returns 200 OK in all cases to prevent email harvesting

4.2. Server gets user object from the database

4.3. Server generates a reset password token and stores it on `user.reset_password_token`

4.4. Server sets `user.reset_password_token_expiration = Date.now() + (30 * 60 * 1000)` (30 minutes from now)

4.5. Server saves user object to database

4.6. Server sends email with a link to the `/account/reset_password` page that encodes the `reset_password_token` and their email address in the URL.

4.7. Server returns `200 OK`

5. User clicks the reset password link in the email to navigate to the `/account/reset_password` page with the `reset_password_token` in the URL

6. User types a new password

6.1. The client page checks that the password is valid using `common/account/sanity_check.js:isPasswordValid(password)` every time the user types a character

6.2. If the password is invalid, the client page displays an error message and the user is not allowed to submit the form

6.3. If the password is valid, the field turns green and the user can click the "reset password" button

7. User clicks the "reset password" button

7.1. The client page invokes the `/api/v1/account/reset_password` endpoint with the user's email address, the new password, and `reset_password_token`

7.2. The server validates the `reset_password_token` and email address

7.2.1. If the email address is not found, the reset_password_token does not exist, does not match, or the reset_password_token_expiration has passed, the server returns `400 Bad Request` // these cases are lumped together to prevent leaking information about the user's account

7.3. Server validates the new password using `common/account/sanity_check.js:isPasswordValid(password)`

7.3.1. If the password is invalid, the server returns `400 Bad Request`

7.3. Server gets user object from database

7.4. Server deletes `user.reset_password_token` and `user.reset_password_token_expiration` fields from the user object

7.5. Server computes hash of new password and stores it on `user.password_hash` replacing any previous value

7.6. Server saves user object to database

7.7. Server returns `200 OK`

7.8. If the client recieves a 200 OK response, it redirects the user to the `/account/reset_password_success` page

7.9. If the client recieves a 400 Bad Request response, it displays an error message and asks the user to repeat the process from step 1
\end{verbatim}

\hypertarget{api-endpoints}{%
\subsection{API endpoints}\label{api-endpoints}}

Here's a quick summary of the API endpoints broken down by category:

\hypertarget{apiv1account}{%
\subsubsection{\texorpdfstring{\texttt{/api/v1/account/*}}{/api/v1/account/*}}\label{apiv1account}}

\hypertarget{create-password-authenticated-account}{%
\paragraph{\texorpdfstring{\texttt{create-password-authenticated-account}}{create-password-authenticated-account}}\label{create-password-authenticated-account}}

NOTE: This endpoint is only employed when creating an account that is
initially password-authenticated. Accounts that are authenticated using
other means (eg. github authentication) do not use use this endpoint.
Instead, they are created by the `after login' function in
\texttt{/api/v1/auth/{[}...nextauth{]}.js}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  return \texttt{403,\ forbidden} if name, email, or password are not
  valid

  // The password form field will perform sanity checks on the client
  side after every change. This endpoint does not need to return
  human-readable error messages (such as ``password length should be
  between 3 and 256 characters'').
\item
  call server.account.createUser(name, email)
\item
  update the newly created user with the hashed password
\end{enumerate}

3.1. get the newly created user from the database

3.2. set the field \texttt{user.password\_hash} to
\texttt{server.account.hashPassword(password)}

3.3. call \texttt{server.db.updateUser} with the modified user object

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  return \texttt{200,\ ok}
\end{enumerate}

\hypertarget{resend-verification-code}{%
\paragraph{\texorpdfstring{\texttt{resend-verification-code}}{resend-verification-code}}\label{resend-verification-code}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  call server.account.sendVerificationCode with the email address
\item
  return 200, ok
\end{enumerate}

\hypertarget{verify-account}{%
\paragraph{\texorpdfstring{\texttt{verify-account}}{verify-account}}\label{verify-account}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  if the email is not in the database, the user does not need
  verification, the verification time limit has expired, or the code is
  incorrect, return \texttt{400,\ bad\ request}
\item
  remove the verification code and \texttt{verification\_needed} from
  the user object
\end{enumerate}

\hypertarget{delete-account}{%
\paragraph{\texorpdfstring{\texttt{delete-account}}{delete-account}}\label{delete-account}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  call server.account.deleteUser(token.email)
\item
  return \texttt{200,\ ok}
\end{enumerate}

\hypertarget{change-username}{%
\paragraph{\texorpdfstring{\texttt{change-username}}{change-username}}\label{change-username}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  if the username is not valid, return \texttt{400,\ bad\ request}
\item
  get the user object from the database
\item
  change the user.name to the new name
\item
  call server.db.updateUser with the modified user object
\item
  return \texttt{200,\ ok}
\end{enumerate}

\hypertarget{change-email}{%
\paragraph{\texorpdfstring{\texttt{change-email}}{change-email}}\label{change-email}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  if the email is already in use or if the email is not valid, return
  \texttt{400,\ bad\ request}
\item
  get the user object from the database
\item
  change the user.email to the new email
\item
  set the user.email\_verified = false and user.verification\_needed =
  true for the new user
\item
  call server.db.updateUser with the modified user object
\item
  call server.account.sendVerificationEmail for the new user
\item
  return \texttt{200,\ ok}
\end{enumerate}

\hypertarget{change-password}{%
\paragraph{\texorpdfstring{\texttt{change-password}}{change-password}}\label{change-password}}

This endpoint can be used to change the existing password of a
password-authenticated account or to add password authentication to an
account that was using some other authentication method. Unlike
\texttt{reset-password}, it does not require the user to enter a
verification code.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  call server.account.sanityCheck.isValidPassword(password)
\item
  if the password is not valid, return \texttt{403,\ forbidden}

  // The `change password' react component will perform sanity checks on
  the client side after every change to the text field. This endpoint
  does not need to return human-readable error messages (such as
  ``password length should be between 3 and 256 characters'').
\item
  get hash from server.account.hashPassword(password)
\item
  get the user object from the database
\item
  change the user.password\_hash to hash
\item
  call server.db.updateUser with the modified user object
\item
  return \texttt{200,\ ok}
\end{enumerate}

\hypertarget{forgot-password}{%
\paragraph{\texorpdfstring{\texttt{forgot-password}}{forgot-password}}\label{forgot-password}}

See sequence diagram ``Password Reset'' for details.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  if the email address is not found, return \texttt{200\ OK} // the
  server returns 200 OK in all cases to prevent email harvesting
\item
  get user object from the database
\item
  generate a reset password token and stores it on
  \texttt{user.reset\_password\_token}
\item
  set
  \texttt{user.reset\_password\_token\_expiration\ =\ Date.now()\ +\ (30\ *\ 60\ *\ 1000)}
  (30 minutes from now)
\item
  save user object to database
\item
  Server sends email with a link to the
  \texttt{/account/reset\_password} page that encodes the
  \texttt{reset\_password\_token} and their email address in the URL.
\item
  return \texttt{200\ OK}
\end{enumerate}

\hypertarget{reset-password}{%
\paragraph{\texorpdfstring{\texttt{reset-password}}{reset-password}}\label{reset-password}}

See sequence diagram ``Password Reset'' for details.

POST with params: user's email address, the new password, and
\texttt{reset\_password\_token}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The server validates the \texttt{reset\_password\_token} and email
  address
\end{enumerate}

1.1. If the email address is not found, the reset\_password\_token does
not exist, does not match, or the reset\_password\_token\_expiration has
passed, the server returns \texttt{400\ Bad\ Request} // these cases are
lumped together to prevent leaking information about the user's account

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  validate the new password using
  \texttt{common/account/sanity\_check.js:isPasswordValid(password)}
\end{enumerate}

2.1. If the password is invalid, return \texttt{400\ Bad\ Request}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  get user object from database
\item
  delete \texttt{user.reset\_password\_token} and
  \texttt{user.reset\_password\_token\_expiration} fields from the user
  object
\item
  compute hash of new password and stores it on
  \texttt{user.password\_hash} replacing any previous value
\item
  save user object to database
\item
  return \texttt{200\ OK}
\end{enumerate}

\hypertarget{apiv1auth...nextauth.js}{%
\subsubsection{\texorpdfstring{\texttt{/api/v1/auth/{[}...nextauth{]}.js}}{/api/v1/auth/{[}...nextauth{]}.js}}\label{apiv1auth...nextauth.js}}

\hypertarget{password-login}{%
\paragraph{\texorpdfstring{\texttt{password\ login}}{password login}}\label{password-login}}

This is not a direct API route. It is called to authenticate a user with
a password.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  call server.account.hashPassword(password)
\item
  look for email-hash match in user\_db
\item
  return appropriate boolean response
\end{enumerate}

\hypertarget{after-login}{%
\paragraph{\texorpdfstring{\texttt{after\ login}}{after login}}\label{after-login}}

This is not a direct API route. It is called after a user has been
authenticated regardless of the authentication method.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  get the user object with jwt.getToken()
\item
  if the user's email is not in the user\_db,
\end{enumerate}

2.1. call server.account.createUser(email, name)

2.2. if jwt token user has a \texttt{picture} field, store this value on
the user object // we don't want to do this after every login; only the
first

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  record the last login time in user\_db
\item
  update the user object in the database
\end{enumerate}

\hypertarget{apiv1apps}{%
\subsubsection{\texorpdfstring{\texttt{/api/v1/apps/*}}{/api/v1/apps/*}}\label{apiv1apps}}

\hypertarget{list}{%
\paragraph{\texorpdfstring{\texttt{list}}{list}}\label{list}}

This is a graphql-like endpoint that returns any subset of the apps that
the user has access to. The client supplies a \texttt{json} object with
fields for each app that the user wants to see. The server returns a
\texttt{json} object with the same fields, but with the values replaced
by the values from the database.

\hypertarget{run}{%
\paragraph{\texorpdfstring{\texttt{run}}{run}}\label{run}}

\hypertarget{server-only-code}{%
\subsection{Server-only code}\label{server-only-code}}

\hypertarget{serveraccount}{%
\subsubsection{\texorpdfstring{\texttt{/server/account/*}}{/server/account/*}}\label{serveraccount}}

\hypertarget{hashpasswordpassword}{%
\paragraph{\texorpdfstring{\texttt{hashPassword(password)}}{hashPassword(password)}}\label{hashpasswordpassword}}

\hypertarget{getuseremail-res}{%
\paragraph{\texorpdfstring{\texttt{getUser(email,\ res?)}}{getUser(email, res?)}}\label{getuseremail-res}}

If \texttt{res} is provided, the function will redirect to the
verify\_email page if
\texttt{user.verification\_needed\ \&\&\ user.verification\_needed==true}.
It is strongly encouraged to include the \texttt{res} parameter to
eliminate the need for maintaining manual redirect logic. Also cleans
the user object of the \texttt{verification\_code},
\texttt{verification\_code\_expiration}, \texttt{verification\_needed},
\texttt{reset\_password\_token}, and
\texttt{reset\_password\_token\_expiration} fields if they are expired
or unnecessary.

\hypertarget{updateuseremail-user}{%
\paragraph{\texorpdfstring{\texttt{updateUser(email,\ user)}}{updateUser(email, user)}}\label{updateuseremail-user}}

Completely replaces the user object in the database with the new user
object. This function should be the only method used to update the user
object in the database since it forces API logic to call
\texttt{getUser} which in turn force handles redirect logic.

\hypertarget{createusername-email}{%
\paragraph{\texorpdfstring{\texttt{createUser(name,\ email)}}{createUser(name, email)}}\label{createusername-email}}

NOTE: This function does not perform any sanity checks on the user
parameters since they are already performed to the extent possible by
create-password-authenticated-account. We cannot restrict a user from
creating an account with a name that is already in use just because they
are using OATH with a name or email that does not pass the sanity check.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Obtain a unique user id from the database
\item
  Create a new user object with the following fields:
\end{enumerate}

\begin{itemize}
\tightlist
\item
  uid
\item
  name
\item
  email
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Create a directory for the user's files in \texttt{/storage}
\item
  Store the user object in the database
\end{enumerate}

\hypertarget{deleteuseremail}{%
\paragraph{\texorpdfstring{\texttt{deleteUser(email)}}{deleteUser(email)}}\label{deleteuseremail}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  mark user.deleted = true in database
\end{enumerate}

// For now, we do not need to delete folders in /storage

\hypertarget{sendverificationcodeemail}{%
\paragraph{\texorpdfstring{\texttt{sendVerificationCode(email)}}{sendVerificationCode(email)}}\label{sendverificationcodeemail}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Generate a verification code
\item
  Set the \texttt{user.verification\_code} to the verification code
\item
  Set the \texttt{user.verification\_code\_expiration} to the current
  time plus 30 minutes
\item
  Set the \texttt{user.verification\_needed} to true
\item
  Delete the \texttt{user.reset\_password\_token} and
  \texttt{user.reset\_password\_token\_expiration} fields from the user
  object
\item
  Send the verification code to the user's email with a one-tap link
  that automatically verifies the user's email
\end{enumerate}

\hypertarget{file-permissions}{%
\section{File Permissions}\label{file-permissions}}

Ideally, we want to implement a Google-Drive-kind-of sharing
architecture where \textbf{users and groups can own and share files and
directories with fine-tuned permission levels (hidden, read, write,
admin, owner)}. For brevity, this document refers to both files and
directories as ``resources''. A resource can only have one owner. The
current \emph{owner} can change the owner and administrate files; all
users with an \emph{admin} permission level can delete, move, rename,
and share, and they also have write permissions; all users with
\emph{write} permissions can edit files, and they also have read
permissions; and all users with \emph{read} permissions can read, copy,
and download files. A resource can also be explicitly marked as `hidden'
for some particular entity. Users inherit the permissions of the
group(s) they belong to with conflicts determined by a least restrictive
union.

Initially, a newly created or uploaded file is owned by the user or
group who created or uploaded it. That owner can then share the file
with other users or groups, giving them read-only access.

In many cases, file access permissions are inherited from the parent
directory. For example, if a user creates a new file in a directory, the
file's owner is the user who owns the directory. Inherited permissions
can also override the parent directory's permissions. For example, UserA
could be given reader permissions on
\texttt{/storage/userB/sharedFolder} but also hidden permissions on
\texttt{/storage/userB/sharedFolder/file.txt}. This would make UserA
able to read everything in \texttt{/storage/userB/sharedFolder/} except
for \texttt{file.txt}.

The Anonymous and System users are special users that are used on the
backend to implement some of sharing architecture features.

\begin{itemize}
\tightlist
\item
  The System user owns the storage root directory and each entity's
  top-level directory. Users and groups have admin permissions on their
  own top-level directory.
\item
  The Anonymous user has hidden permissions on the root storage
  directory.
\end{itemize}

See \href{/docs/users_and_groups.md}{users and groups} for more
information.

\textbf{Inherited vs explicit permissions}. Explicit permissions are
explicitly assigned to a resource while inherited permissions are
implicitly acquired from the parent directory of a resource. Whenver an
admin views permissions on a file or directory, they want to see both
inherited and explicit permissions set on that resource. On the other
hand, when permissions are assigned to a resource, these are assigned to
become explicit permissions.

Removing explicit permissions is not the same as revoking inherited
permissions. The sharing dialog presents a list of entities that the
resource is shared with. Users can select \texttt{hidden} to explicitly
revoke access to a resource. They can also click a delete icon to simply
revert access permissions for that resource to its parent directory.

Whenever an explicit permission to read, write, administrate, or own a
resource is assigned to an entity, the path to that resource is stored
on the entity's list of shared resources. This list allows the user
interface to make a ``shared with me'' type of sidebar menu for
resources which would otherwise be buried under hidden parent
directories. This list is updated whenever explicit permissions are
revoked, changed to hidden, or the filesystem resource is deleted. This
list is also updated every time the server restarts, which should be
nightly.

\textbf{There is a potential security exploit} with this approach:
assume I have a file system like this:

\begin{verbatim}
├── jacob
├── org1 (admin: Jacob)
|  ├── file 1
|  └── folder 1
|     ├── folder 1.1
|     └── folder 1.2
...
\end{verbatim}

By giving Jacob admin rights to \texttt{org1}, he inherently has admin
rights on all its subdirectories. Therefore, Jacob could explicitly
grant himself access like so:

\begin{verbatim}
├── jacob
├── org1 (admin: Jacob)
|  ├── file 1 (admin: Jacob)
|  └── folder 1 (admin: Jacob)
|     ├── folder 1.1 (admin: Jacob)
|     └── folder 1.2 (admin: Jacob)
...
\end{verbatim}

Then, even if the \texttt{org1} owner removes Jacob from the group, he
will still have control over the group's resources that he has
explicitly assigned admin permissions for himself.

\begin{verbatim}
├── jacob
├── org1
|  ├── file 1 (admin: Jacob; Jacob can still see this folder)
|  ├── file 2 (Jacob can't see this newly created file)
|  └── folder 1 (admin: Jacob; Jacob can still see this folder)
|     ├── folder 1.1 (admin: Jacob; Jacob can still see this folder)
|     └── folder 1.2 (admin: Jacob; Jacob can still see this folder)
...
\end{verbatim}

To prevent attacks like this from happening unintentionally, when a user
is revoking explicit permissions on a directory, they should receive a
request like ``Do you want to revoke permissions for all child
directories as well?''. If the user clicks ``yes'', then the system
should recursively remove permissions for all child directories as well.

\textbf{Navigation}. Users navigate to resources by selecting one of:
``My files'', ``Shared with me'', ``GroupA's files'', ``Shared with
GroupA'', and etc. for all groups that the user belongs to. Then the
main content panel is filled with a list or tile of resources which they
can click through to arrive a a resource. There is also a top-level
search bar / breadcrumbs display which allows users to search for
resources by name, by tag (future), or by path. For security reasons,
the server treats hidden resources as if they didn't exist and responds
with a not found error.

Explicit permissions are shaped as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ Permission }\OperatorTok{\{}
\NormalTok{  path}\OperatorTok{:} \DataTypeTok{string}\OperatorTok{!}
\NormalTok{  entity}\OperatorTok{:}\NormalTok{ ID}\OperatorTok{!}
\NormalTok{  permission}\OperatorTok{:}\NormalTok{ PermissionLevel}\OperatorTok{!}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

They are stored in the Prisma-connected database.

Note: the \texttt{owner} of a resource does not have to be the user who
created the resource or the entity under whose top-level directory the
rersource is located in.

\textbf{Groups}. When a user is added to a group, the UI asks the
inviter whether they would like to assign \texttt{reader},
\texttt{writer}, or \texttt{admin} permissions to that new user for that
group's root directory. The group owner has admin permissions. (The
system user is the owner of all entity top-level directories).
Conversely, the UI asks if the group owner would like to revoke those
permissions when removing a user from the group.

\hypertarget{live-editing}{%
\section{Live Editing}\label{live-editing}}

Collaborative editing and viewing is a really cool yet increasingly
essential feature of the web. Here more than ever, we developers need to
rely on existing conventions and modules to minimize essential and
accidental complexities. GraphQL subscriptions coupled with declarative
react data fetching and rendering is a great way to make this happen.
Here's a quick and dirty example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// copilot generated this as an example}
\KeywordTok{const} \OperatorTok{\{}\NormalTok{ useSubscription }\OperatorTok{\}} \OperatorTok{=} \AttributeTok{require}\NormalTok{(}\StringTok{"@apollo/react-hooks"}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const} \OperatorTok{\{}\NormalTok{ gql }\OperatorTok{\}} \OperatorTok{=} \AttributeTok{require}\NormalTok{(}\StringTok{"apollo-boost"}\NormalTok{)}\OperatorTok{;}

\KeywordTok{function} \AttributeTok{useDocumentChanges}\NormalTok{(document_id) }\OperatorTok{\{}
  \KeywordTok{const} \OperatorTok{\{}\NormalTok{ data}\OperatorTok{,}\NormalTok{ loading}\OperatorTok{,}\NormalTok{ error }\OperatorTok{\}} \OperatorTok{=} \AttributeTok{useSubscription}\NormalTok{(}
\NormalTok{    gql}\VerbatimStringTok{`subscription \{}
\VerbatimStringTok{      document_changes(document_id: }\SpecialCharTok{$\{}\NormalTok{document_id}\SpecialCharTok{\}}\VerbatimStringTok{) \{}
\VerbatimStringTok{        id}
\VerbatimStringTok{        type}
\VerbatimStringTok{        data}
\VerbatimStringTok{      \}}
\VerbatimStringTok{    \}`}
\NormalTok{  )}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (loading) }\ControlFlowTok{return} \KeywordTok{null}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (error) }\ControlFlowTok{return} \KeywordTok{null}\OperatorTok{;}
  \ControlFlowTok{return} \VariableTok{data}\NormalTok{.}\AttributeTok{document_changes}\OperatorTok{;}
\OperatorTok{\}}

\KeywordTok{function} \AttributeTok{useDocument}\NormalTok{(document_id) }\OperatorTok{\{}
  \KeywordTok{const}\NormalTok{ changes }\OperatorTok{=} \AttributeTok{useDocumentChanges}\NormalTok{(document_id)}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\NormalTok{changes) }\ControlFlowTok{return} \KeywordTok{null}\OperatorTok{;}
  \KeywordTok{const}\NormalTok{ [state}\OperatorTok{,}\NormalTok{ setState] }\OperatorTok{=} \AttributeTok{useState}\NormalTok{(changes[}\DecValTok{0}\NormalTok{].}\AttributeTok{data}\NormalTok{)}\OperatorTok{;}
  \VariableTok{changes}\NormalTok{.}\AttributeTok{forEach}\NormalTok{((change) }\KeywordTok{=>} \OperatorTok{\{}
    \AttributeTok{setState}\NormalTok{(}\VariableTok{change}\NormalTok{.}\AttributeTok{data}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{return}\NormalTok{ state}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Currently, the server does not feature applications that would utilize
collaborative editing. However, in the future, users may be able to
write reports, create block-based workflows, and comment on other users'
reports and outputs in close to real-time. If I have time, I might use
\texttt{mantine/rtf} and (\texttt{react-blockly} or \texttt{react-flow})
to implement this.
