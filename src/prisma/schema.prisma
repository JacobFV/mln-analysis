// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator client {
  provider = "prisma-client-js"
}

model Email {
  id                     String    @id @default(cuid())
  email                  String    @unique
  needsVerification      Boolean   @default(true)
  verificationCode       String?
  verificationCodeSentOn DateTime?
  user                   User      @relation(fields: [userId], references: [id])
  userId                 String
  primary                Boolean?
}

/// Stores all login attempts (credential based and oath)
/// Of course, OAuth login attempts will always succeed
model LoginAttempt {
  id        Int      @id @default(autoincrement())
  ip        String
  userAgent String
  headers   String
  timestamp DateTime
  email     String
  success   Boolean
  user      User     @relation(fields: [userId], references: [id])
  userId    String
}

model GroupMembership {
  id          String   @id @default(cuid())
  group       Entity   @relation("GroupMembershipGroup", fields: [groupId], references: [id])
  groupId     String
  entityRef   Entity   @relation("GroupMembershipEntity", fields: [entityRefId], references: [id])
  entityRefId String
  joinedAt    DateTime @default(now())
}

/// This model represents a union type between users and groups
/// You will need to perform a runtime cast in typescript to use it
model Entity {
  id   String @id @default(cuid()) /// this id is used a a global point of reference for users and groups
  type String @default("user") /// either "user" or "group"; may add more types later

  // common attributes
  name                    String               @unique
  picture                 String
  createdAt               DateTime             @default(now())
  updatedAt               DateTime             @updatedAt
  deleted                 Boolean              @default(false)
  deletedAt               DateTime?
  memberOfGroups          GroupMembership[]    @relation("GroupMembershipEntity")
  permissionsAssignedToMe ExplicitPermission[] @relation("PermissionsAssignedToMe")

  /// user-specific attributes
  emails                     Email[]
  loginAttempts              LoginAttempt[]
  pswHash                    String?
  ownerOfGroups              Group[]              @relation("GroupOwners")
  explicitPermissionsCreated ExplicitPermission[] @relation("ExplicitPermissionsCreated") // permissions that the user has added to other files (including ones that the user does not own)

  /// group-specific fields
  owner   Entity? @relation("GroupOwners", fields: [ownerId], references: [id])
  ownerId String?
  members GroupMembership?[] @relation("GroupMembershipGroup")
}

model ExplicitPermission {
  id                String   @id @default(cuid())
  path              String
  appliesTo         Entity   @relation("PermissionsAssignedToMe", fields: [appliesToEntityId], references: [id]) /// the entity that the permissions are applied to
  appliesToEntityId String
  permissionLevel   String /// 'HIDDEN', 'READ', 'WRITE', 'ADMIN', 'OWNER'
  createdOn         DateTime @default(now())
  createdBy         User     @relation("ExplicitPermissionsCreated", fields: [createdById], references: [id])
  createdById       String
}
