// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "./db.sqlite"
}

/// TODO: create and delete a corresponding EntityUnions when a user is created or deleted
model User {
  id                       String               @id @default(cuid())
  entityRef                EntityUnion          @relation("EntityRef", fields: [entityUnionId], references: [id])
  emails                   Email[]
  loginAttempts            LoginAttempt[]
  pswHash                  String?
  ownerOfGroups            Group[]              @relation("GroupOwners")
  explicitPermissionsAdded ExplicitPermission[] @relation("ExplicitPermissionsAdded")
  entityUnionId            String               @unique
}

model Email {
  id                     String    @id @default(cuid())
  email                  String    @unique
  needsVerification      Boolean
  verified               Boolean?
  verificationCode       String?
  verificationCodeExpiry DateTime?
  user                   User      @relation(fields: [userId], references: [id])
  userId                 String
  primary                Boolean?
}

/// Stores all login attempts (credential based and oath)
/// Of course, OAuth login attempts will always succeed
model LoginAttempt {
  id        Int      @id @default(autoincrement())
  ip        String
  userAgent String
  timestamp DateTime
  email     String
  success   Boolean
  user      User     @relation(fields: [userId], references: [id])
  userId    String
}

/// TODO: create and delete a corresponding EntityUnion when a group is created or deleted
model Group {
  id            String            @id @default(cuid())
  entityRef     EntityUnion       @relation("EntityRef", fields: [entityUnionId], references: [id])
  name          String
  picture       String
  createdAt     DateTime
  updatedAt     DateTime          @updatedAt
  owner         User              @relation("GroupOwners", fields: [ownerId], references: [id])
  ownerId       String
  members       GroupMembership[] @relation("GroupMembershipGroup")
  entityUnionId String            @unique
}

model GroupMembership {
  id          String      @id @default(cuid())
  group       Group       @relation("GroupMembershipGroup", fields: [groupId], references: [id])
  groupId     String
  entityRef   EntityUnion @relation("GroupMembershipEntity", fields: [entityRefId], references: [id])
  entityRefId String
}

/// This model is used to make a union type between users and groups
model EntityUnion {
  /// dirty hack to make the union type work
  id               String            @id // should be set to the id of the user or group
  user             User?             @relation(name: "EntityRef")
  group            Group?            @relation(name: "EntityRef")
  // common attributes
  name             String
  picture          String
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  deleted          Boolean           @default(false)
  deletedAt        DateTime?
  // advanced attributes
  groupMemberships GroupMembership[] @relation("GroupMembershipEntity")

  explicitlyAssignedPermissions ExplicitPermission[] @relation("ExplicitlyAssignedPermissions")
}

model ExplicitPermission {
  id         String      @id @default(cuid())
  path       String
  entity     EntityUnion @relation("ExplicitlyAssignedPermissions", fields: [entityId], references: [id]) /// the entity that the permissions are applied to
  entityId   String
  permission String /// hidden, reader, writer, or admin
  createdAt  DateTime    @default(now())
  addedBy    User        @relation("ExplicitPermissionsAdded", fields: [addedById], references: [id])
  addedById  String
}

// type App {
//   name: String,
//   description: String,
//   version: String,
//   invocation_template: String, // eg. `node ./index.js $arg1 --arg2 $arg3`
//   inputs: {
//     [name: string]: {
//       type: Type,
//       description: string,
//       required: boolean,
//       default: any,
//     },
//   },
//   outputs: {
//     [name: string]: {
//       type: Type,
//       description: string,
//     },
//   },
// }
// db {
//   users: [User!]!
//   organizations: [Organization!]!
//   filePermissions: [String: FilePermission!]! // key is filepath
//   // there is no persistent data for files; we use the OS filesystem instead!
//   apps: [App!]!
// }
