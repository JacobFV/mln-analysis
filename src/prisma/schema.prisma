// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

/// TODO: create and delete a corresponding EntityUnions when a user is created or deleted
model User {
  /// id should not be used for purposes other than uniqueness. Not the same as the user or group id
  id String @id @default(cuid())

  entityRef                  EntityUnion          @relation("UserEntityRef", fields: [entityUnionId], references: [id])
  emails                     Email[]
  loginAttempts              LoginAttempt[]
  pswHash                    String?
  ownerOfGroups              Group[]              @relation("GroupOwners")
  explicitPermissionsCreated ExplicitPermission[] @relation("ExplicitPermissionsCreated") // permissions that the user has added to other files (including ones that the user does not own)
  entityUnionId              String               @unique
}

model Email {
  id                     String    @id @default(cuid())
  email                  String    @unique
  needsVerification      Boolean
  verified               Boolean?
  verificationCode       String?
  verificationCodeExpiry DateTime?
  user                   User      @relation(fields: [userId], references: [id])
  userId                 String
  primary                Boolean?
}

/// Stores all login attempts (credential based and oath)
/// Of course, OAuth login attempts will always succeed
model LoginAttempt {
  id        Int      @id @default(autoincrement())
  ip        String
  userAgent String
  headers   String
  timestamp DateTime
  email     String
  success   Boolean
  user      User     @relation(fields: [userId], references: [id])
  userId    String
}

/// TODO: delete a corresponding EntityUnion when a group is created or deleted
model Group {
  /// id should not be used for purposes other than uniqueness. Not the same as the user or group id
  id String @id @default(cuid())

  entityRef     EntityUnion       @relation("GroupEntityRef", fields: [entityUnionId], references: [id])
  owner         User              @relation("GroupOwners", fields: [ownerId], references: [id])
  ownerId       String
  members       GroupMembership[] @relation("GroupMembershipGroup")
  entityUnionId String            @unique
}

model GroupMembership {
  id          String      @id @default(cuid())
  group       Group       @relation("GroupMembershipGroup", fields: [groupId], references: [id])
  groupId     String
  entityRef   EntityUnion @relation("GroupMembershipEntity", fields: [entityRefId], references: [id])
  entityRefId String
  joinedAt    DateTime    @default(now())
}

/// This model is used to make a union type between users and groups
model EntityUnion {
  id String @id @default(cuid()) /// this id is used a a global point of reference for users and groups

  /// This is dirty hack to make the union type work
  user  User?  @relation(name: "UserEntityRef")
  group Group? @relation(name: "GroupEntityRef")

  // common attributes
  name      String
  picture   String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deleted   Boolean   @default(false)
  deletedAt DateTime?

  // advanced attributes
  memberOfGroups GroupMembership[] @relation("GroupMembershipEntity")

  // permissions where the user or group is a reciever or read/write/admin access. This is used for the "Shared with me" feature
  explicitlyAssignedPermissions ExplicitPermission[] @relation("ExplicitlyAssignedPermissions")
}

model ExplicitPermission {
  id                String      @id @default(cuid())
  path              String
  appliesTo         EntityUnion @relation("ExplicitlyAssignedPermissions", fields: [appliesToEntityId], references: [id]) /// the entity that the permissions are applied to
  appliesToEntityId String
  permissionLevel   String /// 'HIDDEN', 'READ', 'WRITE', or 'ADMIN'
  createdOn         DateTime    @default(now())
  createdBy         User        @relation("ExplicitPermissionsCreated", fields: [createdById], references: [id])
  createdById       String
}

// type App {
//   name: String,
//   description: String,
//   version: String,
//   invocation_template: String, // eg. `node ./index.js $arg1 --arg2 $arg3`
//   inputs: {
//     [name: string]: {
//       type: Type,
//       description: string,
//       required: boolean,
//       default: any,
//     },
//   },
//   outputs: {
//     [name: string]: {
//       type: Type,
//       description: string,
//     },
//   },
// }
// db {
//   users: [User!]!
//   organizations: [Organization!]!
//   filePermissions: [String: FilePermission!]! // key is filepath
//   // there is no persistent data for files; we use the OS filesystem instead!
//   apps: [App!]!
// }
